
trunc 函数：
	日期的案例，如：

	select trunc(sysdate) from dual --2017/6/13  返回当天的日期

	select trunc(sysdate,'yyyy') from dual   --2017/1/1  返回当年第一天.

	select trunc(sysdate,'mm') from dual  --2017/6/1  返回当月第一天.

	select trunc(sysdate,'d') from dual  --2017/6/11 返回当前星期的第一天(以周日为第一天).

	select trunc(sysdate,'dd') from dual  --2017/6/13  返回当前年月日

	select trunc(sysdate,'hh') from dual  --2017/6/13 13:00:00  返回当前小时

	select trunc(sysdate,'mi') from dual  --2017/6/13 13:06:00  返回当前分钟

TRUNC()函数	在截取时不进行四舍五入，直接截取。

	针对数字的案例，如：

	select trunc(123.458) from dual --123

	select trunc(123.458,0) from dual --123

	select trunc(123.458,1) from dual --123.4

	select trunc(123.458,-1) from dual --120
tunc() 注意： 不改变格式 ，date 截取后仍是date 格式， trunc(to_date())出来的才是date 格式


笛卡尔积：
	加条件就可以去除笛卡尔积，一般都是找外键
	--两张表之间如果没有必然的联系,即不存在外键约束等.
	--如果要相关联这两张表查询数据,那么就只能是用内连接的方式进行查询..
	--==什么是笛卡尔积？无条件直接查询多张表数据


over (partition by  ... order by ...)

 row_number()  over() :
		    在使用 row_number() over()函数时候，
		     over()里头的分组以及排序的执行晚于 where 、group by、  order by 的执行。

partition by   :     mysql group_contact???  group_concat + substr等函数处理; 
		思路： SELECT TABLE_NAME,SUBSTRING_INDEX(GROUP_CONCAT(id ORDER BY id DESC ),',',1)FROM mgr_table.............
								
	       相比较于group by，能够在保留全部数据的基础上，只对其中某些字段做分组排序（类似excel中的操作），
	         eg:
		select * from(
  		select  a.mv_id,a.patient_id,a.record_id,a.cur_state,a.update_time,a.cur_station_id,
        		row_number() over(partition by a.record_id  order by a.update_time desc) rn 
         		 from  patient_movement   a ) pm  where rn = 1   ; 



rank()  row_number() dense_rank() 区别：
				1.rank()和dense_rank()都可以将并列第一名的都查找出来；但rank()是跳跃排序，
					有两个第一名时接下来是第三名；而dense_rank()是非跳跃排序，有两个第一名时接下来是第二名。
				2.求第一名成绩的时候，不能用row_number()，因为如果同班有两个并列第一，row_number()只返回一个结果。


first_value () over() 和 last_value()  over()的使用：
					last_value(t.sroce) over(partition by t.class order by t.sroce desc) mm from T2_TEMP t;
			　	lag() over(partition by ... order by ...)--取出前n行数据。　　
　　				lead() over(partition by ... order by ...)--取出后n行数据。






