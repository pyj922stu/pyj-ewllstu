

https://baike.baidu.com/item/ECMAScript%206/22641264?fromtitle=ES6&fromid=24088827&fr=aladdin

阮一峰 es6 : https://es6.ruanyifeng.com/#docs/style

let:
           let  < var ，只在自己所在代码块起作用，即{}中，同一域中重复声明变量 --》报错
						不能在 函数内部 相同模块 范围重新声明参数。
			
			eg：
		  {
		  let a = 10;
			  var b = 1;
			}
			console.log(b); // 1
			console.log(a); // 报错a没有定义
			
		eg2:
			let a = 10;// 即使声明是var a = 10;后面一样报错
			let a = 1;// 报错
			 
			function func(arg) {
			  let arg; // 调用时因同范围重名报错
			}
			 
			function func(arg) {
			  {
				let arg; // 不报错，因为对上一个arg来看在子模块中
			  }
			}
			
			
		eg3：
			for循环还有一个特别之处，就是设置循环变量的那部分是一个单独的父作用域，
			而循环体内部是子作用域：
				let i = 123;
				console.log(i);
				for (let i = 0; i < 2; i++,console.log(i)) {
				  let i = 'abc';
				  console.log(i);
				}
				// 123
				// abc
				// 1
				// abc
				// 2
				
		4. let实际上为JavaScript新增了块级作用域，在{}被包围的范围外，不受内层的let变量影响
		  （但会受var的“变量提升”影响）：
		  
		  eg4:
		  function text1(){
			  let n = 5; //或var n = 5;
			  if (true) {
				let n = 10;
			  }
			  console.log(n); // 5
			}
 
			function text2(){
			  var n = 5;
			  if (true) {
				var n = 10;
			  }
			  console.log(n); // 10
			}
 
			function text3(){
			  let n = 5;
			  if (true) {
				var n = 10; //报错，已经声明了n
			  }
			}


2. const命令
			const声明一个只读的常量。一旦声明，常量的值就不能改变，
			且声明时必须立即初始化，不能留到以后赋值。const的作用域与let命令相同：
			只在声明所在的块级作用域内有效		
				
			保证的，并不是变量的值不得改动，而是变量指向的那个 内存地址 不得改动。	
			eg：
				const foo = {}; // const foo = []同理，可以正常使用push等功能
				foo.prop = 123; // 为foo添加一个属性，可以成功
				console.log(foo.prop); //123
				foo = {}; // 将foo指向另一个对象，就会报错
			eg:
				对象属性冻结，应该使用 Object.freeze 方法
				
2.2  const 和 let  的优缺点，区别：
					const优于let有几个原因。一个是const可以提醒阅读程序的人，这个变量不应该改变；
					另一个是const比较符合函数式编程思想，运算不改变值，只是新建值，
					而且这样也有利于将来的  分布式运算 ；最后一个原因是 JavaScript 编译器会对const进行优化，
					所以多使用const，有利于提高程序的  运行效率 ，也就是说let和const的本质区别，
					其实是 编译器内部 的处理不同。
				
				
				
				
				
				
				

3.Class 命令	
			  Class（类）这个概念（类的数据类型就是函数，类本身就指向构造函数），作为对象的模板。
				class关键字，可以定义类。class可以看作只是一个语法糖，它的绝大部分功能，
				ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、
				更像面向对象编程的语法而已：
				
				eg：
					function Point(x, y) {
					  this.x = x;
					  this.y = y;
					}
					Point.prototype.toString = function () {
					  return '(' + this.x + ', ' + this.y + ')';
					};
					 
					// 上面为原先写法，下面为ES6的Class写法
					 
					class Point {
					  constructor(x, y) {  // 构造方法，this关键字代表实例对象
						this.x = x;
						this.y = y;
					  }
					  toString() { // 自定义方法，方法之间不需要逗号分隔，加了会报错
						return '(' + this.x + ', ' + this.y + ')';
					  }
					}
					
4.import命令
			1. import虽然属于声明命令，但它是和export命令配合使用的。
			  export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。
			
			2. export命令可以出现在模块的任何位置，只要处于模块顶层就可以。
			  如果处于块级作用域内，就会报错：
			
			3. import命令可以使用as关键字，将输入的变量重命名。除了指定加载某个输出值，
			  还可以使用整体加载，即用*指定一个对象，所有输出值都加载在这个对象上面。
			
			eg:
				import {firstName as name, f, year} from './profile.js';
				import * as p from './profile.js'; 
				
			import 是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。
1					eg：

					import {a} from './xxx.js'; // 也可以是绝对路径，.js后缀可以省略
					 
					a.foo = 'hello'; // 合法操作
					a = {}; // 报错：a是只读的
					 
					import { 'f' + 'oo' } from '/my_module.js';// 报错，语法错误（不能用运算符）
					 
					if (x === 1) { 
					  import { foo } from 'module1'; // 报错，语法错误（import不能在{}内）
					} else {
					  import { foo } from 'module2';
					}
		4. import命令具有提升效果，会提升到整个模块的头部，首先执行。import可以不导入模块中的任何内容，
		  只运行模块中的全局代码。如果多次执行同一模块的import语句，那么只会执行一次其全局代码，但变量均会正常引入（相当于合并处理）。			
					
		eg:			
			foo();
		import { foo } from '/my_module.js'; // 不会报错，因为import的执行早于foo的调用
		import '/modules/my-module.js'; // 不引入变量，但执行其中全局代码
		import { a } from '/modules/my-module.js'; // 重复引入不执行全局代码，但引入变量a
 
 
 
5. 解构赋值  
			只要等号两边的 模式相同，左边的变量就会被赋予对应的值。		
			eg：
				let a = 1;
				let b = 2;
				let c = 3;
				// 等价于
				let [a, b, c] = [1, 2, 3];
			eg2:
				let [x, y, ...z] = ['a'];
					x // "a"
					y // 变量解构不成功，赋值为undefined
					z // 数组解构不成功，赋值为[]
					
			eg3：
				解构赋值允许指定默认值，只有当一个数组成员严格等于undefined，
				默认值才会生效：

				let [foo = true] = []; // foo = true
				let [x, y = 'b'] = ['a']; // x='a', y='b'
				let [q = 1, w = 'b'] = ['a', undefined]; // q='a', w='b'
				let [e = 1] = [null]; // e = null
				
			5.2. 数组。对象 的解构：
					数组的元素是按次序排列的，变量的取值由它的位置决定；
					而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。
					
					eg:
						let { bar, foo } = { foo: "aaa", bar: "bbb" };
						foo // "aaa"
						bar // "bbb"
						 
						let { abc } = { foo: "aaa", bar: "bbb" };
						abc // undefined
						 
						let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
						baz // "aaa"
			
			5.3 用途示例
						解构赋值用途示例：
						
						//交换变量的值
							let x = 1;
							let y = 2;
							[x, y] = [y, x]; 
						 
						//提取 JSON 数据
							let jsonData = {
							  id: 42,
							  status: "OK",
							  data: [867, 5309]
							};
							let { id, status, data: number } = jsonData;
							console.log(id, status, number); // 42, "OK", [867, 5309]
						 
						//遍历 Map 结构
							const map = new Map();
							map.set('first', 'hello');
							map.set('second', 'world');
							 
							for (let [key, value] of map) {
							  console.log(key + " is " + value);
							}
							// first is hello
							// second is world	
							
							
6 .遍历器
		ES6 为字符串添加了遍历器接口，使得字符串可以被for...of循环遍历。除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，
		传统的for循环无法识别这样的码点。
		eg:
			for (let codePoint of 'foo') {
			  console.log(codePoint)
			}
			// "f"
			// "o"
			// "o"
			
7. 兼容问题
			不同浏览器的不同版本对ES6的支持度不同，而Babel是一个广泛使用的ES6转码器，
			可以将ES6代码转为ES5代码，从而在现有环境执行。
			你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持
			
			1.安装 Babel：
			npm install --save-dev @babel/core
			配置文件.babelrc：
			2.Babel 的配置文件是.babelrc，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件。
			
			
			3.presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。
			
			# 最新转码规则
			$ npm install --save-dev @babel/preset-env

			# react 转码规则
			$ npm install --save-dev @babel/preset-react
			然后，将这些规则加入.babelrc。

			  {
				"presets": [
				  "@babel/env",
				  "@babel/preset-react"
				],
				"plugins": []
			  }
			  
			  
8. promise  一种异步解决方案，是一个容器：保存着某个未来才会结束的事件（通常是一个异步操作）的结果
			Promise 是一个对象，从它可以获取异步操作的消息
			
			特点：（1）对象的状态不受外界影响；有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）
												只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态
				  
				  （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果	
						从pending变为fulfilled和从pending变为rejected；    -----resolved（已定型）
						
					可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。
					
			缺点： 1.  无法取消Promise，一旦新建它就会立即执行，无法中途取消
					2. 不设置回调函数，Promise内部抛出的错误，不会反应到外部
					3.  当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。