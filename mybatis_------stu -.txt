
mapper ：
	<trim></trim>标签：

	1. <trim prefix="WHERE" prefixoverride="AND |OR">
		prefix：前缀　 （加上where作为前缀）　　　　　
　　		prefixoverride：去掉第一个and或者是or 
	eg:           where and  a=1 and b=2  这里的第一个and 会被去掉，sql就编译通过
	
	2.<trim prefix="set" suffixoverride="," suffix=" where id = #{id} ">
		suffixoverride ：去掉后缀 “，”
		suffix ： 后缀，作用是 在即将拼接的sql 最后加 “where id = #{id}”

 insert标签
	属性介绍:
	id :唯一的标识符
	parameterType:传给此语句的参数的全路径名或别名 例:com.test.pojo.User

where标签
	“where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，
	如果标签返回的内容是以AND 或OR 开头的，则它会剔除掉。

查询select
	标签属性

	id 唯一的名称，对应dao中mapper的接口名称
	paramterType  定义传入的参数类型
	resultType  返回数据类型对应实体类
	resultMap  外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，对其有一个很好的理解的话，许多复杂映射的情形都能迎刃而解。使用 resultMap 或 resultType，但不能同时使用
	
	flushCache 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：false
	useCache 将其设置为 true，将会导致本条语句的结果被二级缓存，默认值：对 select 元素为 true
	timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）
	fetchSize 这是尝试影响驱动程序每次批量返回的结果行数和这个设置值相等。默认值为 unset（依赖驱动）。
	statementType STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。
	resultSetType FORWARD_ONLY，SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE 中的一个，默认值为 unset （依赖驱动）。
	databaseId 如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。
	resultOrdered 这个设置仅针对嵌套结果 select 语句适用：如果为true，就是假设包含了嵌套结果集或是分组了，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。这就使得在获取嵌套的结果集的时候不至导致内存不够用。默认值：false。
	resultSets 这个设置仅对多结果集的情况适用，它将列出语句执行后返回的结果集并每个结果集给一个名称，名称是逗号分隔的。

if 标签
         基本都是用来判断值是否为空，注意Integer的判断，mybatis会默认把0变成 ‘’

 别名
        经常使用的类型可以定义别名，方便使用，mybatis也注册了很多别名方便我们使用

 
collection与association标签
	collection属性的值有三个分别是list、array、map三种，分别对应的参数类型为：List、数组、map集合。
	collection与association的属性一样，都是用于resultMap返回关联映射使用，collection关联的是集合，而association是关联单个对象
	标签属性
	property resultMap返回实体类中字段和result标签中的property一样
	column 数据库的列名或者列标签别名,是关联查询往下一个语句传送值。注意： 在处理组合键时，您可以使用column=“{prop1=col1,prop2=col2}”这样的语法，设置多个列名传入到嵌套查询语句。这就会把prop1和prop2设置到目标嵌套选择语句的参数对象中。
	javaType 一般为ArrayList或是java.util.List
	ofType java的实体类，对应数据库表的列名称，即关联查询select对应返回的类
	select 执行一个其他映射的sql语句返回一个java实体类型

resultMap标签
	resultMap属性
	id 唯一标识
	type 返回类型
	extends 继承别的resultMap，可选
	关联其他标签
	id 设置主键使用，使用此标签配置映射关系（可能不止一个）
	result 一般属性的配置映射关系，一般不止一个
		<result column="PAT_IMAGE" property="image" jdbcType="VARCHAR"/>
       		 <result column="PAT_DATE_BIRTH" property="dateBirth" jdbcType="TIMESTAMP"/>
	association 关联一个对象使用
		<association property="toBedInfo" fetchType="eager" column="{id=TO_BED_ID}" select="selectBedInfoRPC" javaType="cc.ewell.pms.pat.entity.BedInfoRPC"/>
	collection 关联一个集合使用
		<collection
               		 property="packageList"
                	columnPrefix="PKG_"
                	resultMap="cc.ewell.pms.pat.adm.mapper.AdmPackageMapper.AdmPackageRPCMap"
                	ofType="cc.ewell.pms.pat.entity.AdmPackageRPC"/>

 foreach标签
	foreach属性
	collection 循环的集合。传的是集合为list，数组为array, 如果是map为java.util.HashMap
	item 循环的key
	index 循环的下表顺序
	open 循环的开头
	close 循环结束
	separator 循环的分隔符

set标签
	set是mybatis提供的一个智能标记，当在update语句中使用if标签时，如果前面的if没有执行，
	则或导致逗号多余错误。使用set标签可以将动态的配置SET 关键字，和剔除追加到条件末尾的任何不相关的逗号。
	
 choose、when、otherwise标签

	有时候我们并不想应用所有的条件，而只是想从多个选项中选择一个。
	MyBatis提供了choose 元素，按顺序判断when中的条件出否成立，如果有一个成立，
	则choose结束。当choose中所有when的条件都不满则时，则执行 otherwise中的sql。类似于Java 的switch 语句，
	choose为switch，when为case，otherwise则为default。if是与(and)的关系，而choose是或（or）的关系


MyBatis提供了一级缓存和二级缓存

一级缓存：
	也称为本地缓存，用于保存用户在一次会话过程中查询的结果，用户一次会话中只能使用一个sqlSession，一级缓存是自动开启的，不允许关闭。
二级缓存：
	也称为全局缓存，是mapper级别的缓存，是针对一个表的查结果的存储，可以共享给所有针对这张表的查询的用户。也就是说对于mapper级别的缓存不同的sqlsession是可以共享的。
SqlSession
	在提交的时候会 清空 本地缓存，因为commit操作一般对应插入、更新或者删除操作，
	清空缓存 防止 读取 脏数据。
注：
 	一级缓存的 生命周期 和SqlSession一致。commit 完就没了
	一级缓存内部 设计简单，只是一个 没有容量限定 的 HashMap，在缓存的功能性上有所欠缺。
	一级缓存 最大范围 是SqlSession内部，有多个SqlSession或者分布式的环境下，数据库写操作会引起 脏数据。
	mybatis和spring整合后进行mapper代理开发，不支持 一级缓存。

一级缓存失效：
	同一个用户使用 不同的SqlSession对象 导致无法看到一级缓存工作。
	在一个SqlSession中使用 条件查询不同 一级缓存也会失效。
	在一个SqlSession使用相同条件，但是，此时在 查询之间（两个查询中间再） 进行 数据修改 操作会导致一级缓存失效。
	在一个SqlSession使用 相同查询 条件此时 手动刷新 缓存时导致一级缓存失败

二级：
	在MyBatis核心配置文件,通过settings标签开发二级缓存。
	<setting name="cacheEnabled" value="true"/>
	
	      MyBatis的二级缓存相对于一级缓存来说，实现了SqlSession之间缓存数据的共享，同时粒度更加的细，能够到namespace级别（即同一个Mapper.xml），
	通过Cache接口实现类不同的组合，对Cache的可控性也更强。
	MyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。
	在分布式环境下，由于默认的MyBatis Cache实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将MyBatis的Cache接口实现，有一定的开发成本，
	直接使用Redis,Memcached等分布式缓存可能成本更低，安全性也更高。
	
	原因：
	         一般不要用二级缓存，例如在UserMapper.xml中有大多数针对user表的操作。
	但是在另一个XXXMapper.xml中，还有针对user单表的操作。这会导致user在两个命名空间下的数据不一致。
	如果在UserMapper.xml中做了刷新缓存的操作，在XXXMapper.xml中缓存仍然有效，如果有针对user的单表查询，
	使用缓存的结果可能会不正确，读到脏数据。

